# 2025 南京大学操作系统原理

> 操作系统原理课程学习笔记
> 包括*软件安装，环境配置，运行命令，专有名词，基本概念*等。

[toc]

---

[PPT](https://jyywiki.cn/OS/2025/lect29.md)

---

## 29. 课程总结

在一整个学期的课程中，我们学习了 “应用视角的操作系统”：操作系统就是一组管理了硬件资源、提供应用生态支撑的 API。我们从 “everything is a state machine” 的视角，从 fork/execve/exit 的 “简单模型”，一路见证了虚拟化、云计算、移动操作系统的时代。

---

## 29.1 我们学了个啥？

**A Story on Operating Systems**
**从逻辑门到计算机系统**
**计算机系统的 “公理系统”**

- 数字系统 = 状态机
  - 状态：触发器 (bit array)
  - 迁移：组合逻辑 (真值表)
- Everything is a state machine
  - 操作系统是状态机的管理者

**“数码管” 作为第一个例子**

- UNIX Philosophy 和 “编程” 的力量
  - 彩蛋：复习提纲是使用 UNIX Philosophy 生成的
  - 彩蛋：我们可以让 AI 帮我们

```shell
ls 
./logisim
./logisim | python3 seg-display.py
# workflow
```

**Virtualization**
**状态机管理**

- fork, execve, exit, signal, kill

```shell
$ag
?D:
Are there any interesting use of fork（） system call?
```

**进程的地址空间**

- mmap, munmap, mprotect

**操作系统对象**

- open, pipe, mkfifo, close, read, write

**其他**

- getpid - 进程构成树状的结构

**Concurrency**
**原子操作**

- atomic_inc, atomic_cmpxchg

**线程管理**

- clone (spawn), exit, exit_group

**同步和互斥**

- futex (P, V, join, mutex_lock, mutex_unlock, ...)

**其他**

- gettid

**Persistence**
**文件 (数据 & 元数据) 管理**

- open, read, write, close, stat, chmod, chown, fsetxattr/fgetxattr, ftruncate, ...

**目录树管理**

- mount, mkdir, readdir, link, symlink, unlink, rename, chdir, ...

**一致性管理**

- sync > syncfs > fsync > fdatasync

**其他**

- flock, pivot_root, ...

**从逻辑门到计算机系统**
**打印 Hello World**

- 应用程序 (app) → 加载器 ld.so → 库函数 → 系统调用

**操作系统课给这个稍显复杂的过程一个清晰的轮廓**

- 你可以在其中的每一步都对应到一个**具体的示例代码**
  - “这一切是可以掌控的”

**一个改变全人类的 prompt**

- 我在做 [X]。如果你是一位专业人士，有更好的方法和建议吗？尽可能全面。

**《操作系统》：你的真正 “编程” 启蒙课**
**你不再惧怕任何 “system”**

- 嵌入式系统
- 通用操作系统
- 数据库系统
- 分布式系统
- 二进制安全
- ……

**也不再惧怕任何 “需求” 的实现**

- 只要操作系统能支持的，我就会实现！

**以下命令生成了复习提纲**
```shell
echo lect{1..28}.md | sort -V | xargs cat | grep Demo | awk '!seen[$0]++'

cat lect{1..28}.md | grep Demo | awk '!seen[$0]++' | xclip -c
# 复制到剪贴板
```

>💬Prompt: 上面的命令是如何生成复习提纲的？

这个命令的作用是：把文件名为 lect1.md 到 lect28.md 的所有文件内容按顺序合并，然后筛选出包含 "Demo" 的行，并且只保留首次出现的（去重的）行。具体步骤如下：

    1. echo lect{1..28}.md 生成讲义文件名列表 lect1.md 到 lect28.md。
    2. sort -V 按照版本号排序，确保文件顺序正确。
    3. xargs cat 把这些文件内容合并输出。
    4. grep Demo 筛选出包含 “Demo” 的所有行。
    5. awk '!seen[$0]++' 对输出进行去重，只保留每个 Demo 出现的第一行。

例子 \<Demo path="intro/logisim"/> 和 \<Demo path="intro/mini-rv32ima"/> 就是被筛选出来、且去重后的含有 Demo 的行。

---

## 29.2 回望过去
**引入了更多的 AIGC**

- 嵌入的 `<AIGC promt="..." model="gpt-4.1">`
- 在准备新内容时也大量使用了 AI
  - Prompt: 下面是我的《操作系统》课程 slides，其中的描述是否准确，是否有补充和展开的地方？
- 但我看到了更大的机会
  - 一个完全 “模块化” 的课程


rtfm <a id="rtfm"></a>
[appendix](#RTFM)

- 我还想开一门《Vibe Coding》
  - cursor

---

## 29.3 走向未来
**我看到了编程语言的未来**

- Informal semantics of programming languages
- Monolithic programming
  - 但似乎我只配做世界的观测者？

**是什么让我们为一件事义无反顾？
**
center

> Remember brick walls let us show our dedication. They are there to separate us from the people who don't really want to achieve their childhood dreams. ——[Randy Pausch's last lecture](https://etc.cmu.edu/about/last-lecture)
---

## 29.4 总结

　　***Take-away Messages***: 祝贺每一位坚持到最后的同学！祝愿每个同学都能重新找到并义无反顾地去追求自己的梦想，在任何你领域里，用你的方式去做 “惊为天人” 的东西，推动世界的进步。**我们的征途是星辰和大海。因此，对自己要求高一点。**

---
> RTFM? <a id="RTFM"></a>
[Back](#rtfm)

“Read the Friendly Manual”（RTFM）是一个在技术圈，特别是编程和开源社区中广泛流传的术语。它源自更具攻击性的表达 “Read The Fucking Manual”，但通过将 “Fucking” 替换为 “Friendly” 等温和词汇，来鼓励用户先自主查阅文档解决问题，而非直接提问。

### 📚 1. **核心含义与初衷**

RTFM 的核心精神是 **倡导自助学习和独立解决问题的能力**。它通常用于回应那些通过查阅手册、文档或简单搜索就能解决的基础问题。其背后的理念是，在向他人求助前，自己先尽力寻找答案，这是一种尊重他人时间、并提升自身技能的重要态度。

### 🔄 2. **常见变体与衍生术语**

为了适应不同场合和语气，RTFM 衍生出了许多变体和相关术语：

*   **温和变体**：用于减少攻击性，例如：
    *   **RTFM**：Read The **Friendly** Manual（去读友善的手册）或 Read The **Fine** Manual（去读写得不错的手册）。
    *   **RTM**：直接省略 “F”，即 Read The Manual（去读手册）。
*   **相关缩写**：其思想延伸到其他技术领域：
    *   **STFW**：Search The Fucking Web（去网上搜索一下），强调利用搜索引擎。
    *   **RTFS**：Read The Fucking Source（去读源代码），鼓励直接阅读程序源码来理解问题。
    *   **RTFA**：Read The Fucking Article（去读那篇文章），常用于论坛，提醒回帖前先仔细阅读原文。
*   **文化差异版本**：在英联邦国家，有时会用 **RTBM**（Read The **Bloody** Manual）来表达类似含义。

### 🤖 3. **正确运用RTFM精神**

理解 RTFM 的精髓在于如何有效并友好地运用它：

*   **对提问者**：在提问前，请先完成以下步骤：
    1.  **查阅官方文档（Manual）**：这是最权威的信息来源。
    2.  **善用搜索（STFW）**：使用 Google、百度等搜索引擎尝试解决问题。
    3.  **明确问题**：若仍需提问，请清晰描述问题、背景、已尝试的方法和错误信息。这表明你已付出努力，更容易获得深入解答。
*   **对回答者**：即使想表达 RTFM，也可以采用更友好、更建设性的方式，例如：
    *   “这个问题在官方文档的某一章有详细说明，你可以先参考一下。”
    *   “建议先用这个关键词搜索一下，会有很多详细的教程。”
    *   直接提供相关文档链接。

### 💡 4. **更深层的意义**

RTFM 不仅仅是一句调侃或批评，它背后蕴含的是一种 **积极的学习文化和专业态度**：

*   **促进深度理解**：自主研究的过程能帮助你更深刻地理解问题，而不仅仅是获得一个现成的答案。
*   **赢得社区尊重**：在技术社区中，经过充分研究后提出的高质量问题，更能赢得他人的尊重和乐于帮助。
*   **必备专业素养**：独立查找和消化信息的能力，是许多领域，尤其是技术人员的重要专业素养。

### 💎 总结

“Read the Friendly Manual” 是从一句带点粗鲁的提醒演变而来的、更友善的倡导。它鼓励的是一种 **积极主动、善于利用现有资源的学习方法**。

掌握 RTFM 精神，能让你在学习和解决问题的道路上走得更远、更独立。下次遇到难题时，不妨先愉快地对自已说一句：“RTFM！”

---
> Vibe Coding

“Vibe Coding”是一种由人工智能（AI）驱动的新型编程范式，其核心在于开发者通过自然语言描述功能需求，由大型语言模型（LLM）自动生成代码，从而将开发者的角色从手动编写代码转变为引导、测试和优化AI的输出。这一概念由OpenAI联合创始人、前特斯拉AI负责人Andrej Karpathy在2025年2月正式提出，并迅速在技术社区流行开来。

### 💡 核心概念与工作流程

Vibe Coding 的工作流程通常是迭代式的：
1.  **描述需求 (Description)**: 用户用自然语言描述他们想要软件实现的功能，例如“创建一个带登录功能的简单网站”。
2.  **AI生成代码 (Generation)**: AI编码助手（如 Cursor、GitHub Copilot、Replit Agent 等）根据描述生成相应的代码片段或初始代码库。
3.  **测试与反馈 (Testing and Refinement)**: 用户运行和测试生成的代码。若存在错误或不符合预期，用户可直接将错误信息反馈给AI或调整提示词（Prompt），要求AI修复或改进。
4.  **迭代优化 (Iteration)**: 上述过程循环往复，直至软件满足功能要求。

Karpathy 本人曾形容这种体验为“我几乎不碰键盘……我只是看东西、说东西、运行东西、复制粘贴东西，而它大多情况下都能工作”，并强调这是一种“完全投入感觉，拥抱指数（技术发展），甚至忘记代码存在”的编程方式。

### 🛠️ 主要工具与平台

实践 Vibe Coding 通常需要借助特定的AI编程助手，例如：
*   **Cursor**: 集成了强大AI功能的代码编辑器，支持通过对话生成和修改代码。
*   **GitHub Copilot**: 微软旗下的AI编程助手，提供代码补全和生成功能，并已集成聊天和语音功能。
*   **Replit Agent**: 在线IDE（集成开发环境）中的AI助手，支持通过聊天生成、解释和部署代码。
*   **Windsurf**: 被描述为“代理式IDE”，结合了Copilot风格的辅助和自主任务执行能力。
*   **语音编码工具 (如 Wispr Flow)**: 允许开发者通过语音输入描述需求或命令，进一步简化交互过程，实现“免提编码”。

### 🌟 应用场景与优势

Vibe Coding 在特定场景下展现出显著优势：
*   **快速原型设计与MVP构建**: 对于初创公司或个人开发者，可以在几小时或几天内快速构建出最小可行产品（MVP）或概念原型，极大加速想法验证过程。
*   **降低编程门槛**: 使得没有深厚编程背景的人（如产品经理、设计师或创业者）也能通过描述想法来创建功能性软件，促进了软件的民主化创作。
*   **教育与学习**: 编程新手可以通过观察AI生成的代码来学习编程逻辑和语法，是一种互动性很强的学习方式。
*   **个人化工具开发**: 非常适合开发解决特定个人需求的小工具或“单用户软件”（software for one），例如Kevin Roose开发的冰箱食物管理应用“LunchBox Buddy”。
*   **自动化重复性任务**: 可以快速生成脚本，自动化日常工作中的繁琐任务，如文件处理、数据抓取等。

### ⚠️ 局限性与挑战

尽管前景广阔，Vibe Coding 也面临诸多挑战和批评：
*   **代码质量与可维护性**: AI生成的代码可能存在结构混乱、冗余、缺乏优化或未遵循最佳实践的问题，长期维护困难，容易积累技术债务。
*   **安全隐患**: AI可能会生成包含安全漏洞（如未经充分的输入验证、不安全的加密实践）的代码，若开发者未经安全审查直接使用，会带来严重风险。
*   **“黑箱”调试难题**: 当开发者不完全理解AI生成的代码时，调试和故障排除会变得异常困难，尤其当错误涉及深层逻辑时。
*   **对复杂系统乏力**: 目前Vibe Coding更适用于功能相对独立、逻辑清晰的小型项目或模块。对于大型、复杂且需要精心架构的系统，其效果有限。
*   **过度依赖与技能退化**: 过度依赖AI生成代码可能导致开发者自身编程技能和深层理解能力的退化。甚至有报道提到，有AI助手曾拒绝生成代码，并提醒用户“应该自己开发逻辑”。

### 🔮 未来展望

Vibe Coding 代表了软件开发范式的一次重要演变：
*   **开发者角色转变**: 开发者的重心将从编写具体代码（Syntax）转向更高层次的需求定义、系统架构设计、提示词工程（Prompt Engineering）以及AI输出的质量审核与集成。
*   **多模态交互发展**: 未来的编程交互方式可能更加融合，结合语音、手势甚至视觉界面绘制（“Vibe Design”），使得软件创建过程更加直观。
*   **与企业流程的融合**: 随着AI能力的提升，Vibe Coding可能会更深入地融入企业的开发流程中，但**人类的监督、审查和深厚的领域知识在可预见的未来仍将至关重要**。有预测指出，到2030年，AI可能自动化高达80%的日常编码任务。

### 💎 总结：何时选择 Vibe Coding？

*   **适合场景**: 快速原型验证、个人项目、小型工具开发、编程学习辅助、自动化脚本等**对开发速度要求高、对长期维护和绝对可靠性要求相对较低**的场景。
*   **谨慎使用**: 在开发**安全敏感型应用（如金融、医疗）、大型生产级系统、需要严格合规或涉及核心知识产权**的项目时，应非常谨慎地使用AI生成代码，并必须辅以严格的人工代码审查、安全审计和测试。

简而言之，Vibe Coding 是一个强大的工具和思维模式，它并非要完全取代传统编程，而是提供了一个新的抽象层次。**它的核心价值在于扩展现有开发者的能力，并降低创新门槛，但绝不能替代人类的批判性思维、架构设计和最终的责任担当**。
