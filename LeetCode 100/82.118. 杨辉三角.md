# `push_back` 和 `emplace_back` 详解

在 C++ 中，`push_back` 和 `emplace_back` 都是向 vector 尾部添加元素的方法，但它们在实现机制和效率上有重要区别。

## 1. 基本概念

### `push_back`
- 将已存在的对象**拷贝或移动**到容器中
- 需要先构造对象，再添加到容器

### `emplace_back`
- 在容器内存中**直接构造**对象
- 避免不必要的拷贝或移动操作

## 2. 语法对比

```cpp
#include <vector>
#include <string>
using namespace std;

class Person {
public:
    string name;
    int age;
    
    Person(string n, int a) : name(n), age(a) {
        cout << "构造函数调用" << endl;
    }
    
    Person(const Person& other) : name(other.name), age(other.age) {
        cout << "拷贝构造函数调用" << endl;
    }
    
    Person(Person&& other) noexcept : name(move(other.name)), age(other.age) {
        cout << "移动构造函数调用" << endl;
    }
};

int main() {
    vector<Person> people;
    
    // push_back 用法
    Person p1("Alice", 25);
    people.push_back(p1);           // 拷贝构造
    people.push_back(Person("Bob", 30)); // 移动构造
    people.push_back({"Charlie", 35});   // 构造+移动构造
    
    cout << "--- 分隔线 ---" << endl;
    
    // emplace_back 用法
    people.emplace_back("David", 40);    // 直接构造，最高效
    people.emplace_back(string("Eve"), 45); // 直接构造
    
    return 0;
}
```

## 3. 性能差异分析

### 对于简单类型（int, double 等）
```cpp
vector<int> nums;

// 性能几乎相同
nums.push_back(10);
nums.emplace_back(20);
```

### 对于复杂类型（自定义类、string 等）
```cpp
vector<string> words;

// push_back: 构造临时string + 移动构造
words.push_back("hello");  // 等价于 words.push_back(string("hello"))

// emplace_back: 直接构造
words.emplace_back("world");  // 更高效
```

## 4. 实际使用示例

### 示例 1：基本数据类型
```cpp
vector<int> vec;

// 两种方法效果相同
vec.push_back(1);
vec.emplace_back(2);

vector<vector<int>> matrix;
matrix.push_back({1, 2, 3});    // 推荐
matrix.emplace_back(4, 5, 6);   // 错误！不能这样用
matrix.emplace_back(initializer_list<int>{4, 5, 6}); // 正确但繁琐
```

### 示例 2：自定义类
```cpp
class Point {
public:
    int x, y;
    Point(int x, int y) : x(x), y(y) {}
};

vector<Point> points;

// push_back 方式
points.push_back(Point(1, 2));  // 临时对象 + 移动构造
points.push_back({3, 4});       // 临时对象 + 移动构造

// emplace_back 方式（更高效）
points.emplace_back(5, 6);      // 直接构造
```

### 示例 3：嵌套容器
```cpp
vector<vector<pair<string, int>>> data;

// push_back
data.push_back({{"apple", 1}, {"banana", 2}});

// emplace_back
data.emplace_back(initializer_list<pair<string, int>>{
    {"cherry", 3}, {"date", 4}
});

// 更简洁的方式（推荐）
data.push_back({{"cherry", 3}, {"date", 4}});  // 使用push_back更清晰
```

## 5. 特殊情况和使用技巧

### 需要显式构造的情况
```cpp
vector<string> strs;

// 如果参数需要显式转换
strs.emplace_back(5, 'a');           // 构造 "aaaaa"
// strs.push_back(5, 'a');           // 错误！push_back只能接受一个参数

strs.push_back(string(5, 'a'));      // 需要显式构造
```

### 与初始化列表的配合
```cpp
vector<vector<int>> matrix;

// 这些是等价的，但push_back更简洁
matrix.push_back({1, 2, 3});
matrix.emplace_back(initializer_list<int>{1, 2, 3});
```

## 6. 性能测试对比

```cpp
#include <iostream>
#include <vector>
#include <chrono>
#include <string>

using namespace std;
using namespace std::chrono;

class HeavyObject {
    vector<int> data;
public:
    HeavyObject(int size) : data(size, 42) {}
};

void testPerformance() {
    const int COUNT = 100000;
    
    // 测试 push_back
    auto start = high_resolution_clock::now();
    vector<HeavyObject> v1;
    for (int i = 0; i < COUNT; ++i) {
        v1.push_back(HeavyObject(1000));  // 临时对象 + 移动
    }
    auto duration1 = duration_cast<milliseconds>(
        high_resolution_clock::now() - start);
    
    // 测试 emplace_back
    start = high_resolution_clock::now();
    vector<HeavyObject> v2;
    for (int i = 0; i < COUNT; ++i) {
        v2.emplace_back(1000);  // 直接构造
    }
    auto duration2 = duration_cast<milliseconds>(
        high_resolution_clock::now() - start);
    
    cout << "push_back: " << duration1.count() << "ms" << endl;
    cout << "emplace_back: " << duration2.count() << "ms" << endl;
}
```

## 7. 使用建议总结

| 场景 | 推荐方法 | 理由 |
|------|----------|------|
| 添加已存在的对象 | `push_back` | 语义清晰 |
| 从临时对象添加 | `push_back` | 移动构造效率足够 |
| 直接构造新对象 | `emplace_back` | 避免不必要的拷贝/移动 |
| 简单类型（int等） | 两者均可 | 性能差异很小 |
| 需要构造参数 | `emplace_back` | 可以直接传递参数 |
| 初始化列表 | `push_back({...})` | 语法更简洁 |

### 通用准则：
1. **优先使用 `emplace_back`** 当需要直接构造对象时
2. **使用 `push_back`** 当代码可读性更重要时，或者处理初始化列表
3. **对于简单类型**，选择哪个主要基于代码风格偏好

```cpp
// 现代C++推荐写法
vector<string> names;
names.emplace_back("Alice");        // 高效
names.push_back("Bob");             // 也可以，但稍低效
names.push_back(string("Charlie")); // 不推荐，效率低

vector<vector<int>> matrix;
matrix.push_back({1, 2, 3});        // 简洁清晰
```

记住：**`emplace_back` 在性能上通常更优，但 `push_back` 在某些情况下代码更清晰。**