**不，递归的时间复杂度不一定都高。** 递归的时间复杂度取决于递归的实现方式和问题特性。

## 递归时间复杂度的几种情况

### 1. **高效的递归** ✅

**示例：二分查找（递归版）**
```cpp
int binarySearch(vector<int>& nums, int target, int left, int right) {
    if (left > right) return -1;
    
    int mid = left + (right - left) / 2;
    if (nums[mid] == target) return mid;
    else if (nums[mid] < target) 
        return binarySearch(nums, target, mid + 1, right);
    else 
        return binarySearch(nums, target, left, mid - 1);
}
```
- **时间复杂度：O(log n)** - 每次递归问题规模减半
- 效率与迭代版本相同

**示例：归并排序**
```cpp
void mergeSort(vector<int>& arr, int left, int right) {
    if (left < right) {
        int mid = left + (right - left) / 2;
        mergeSort(arr, left, mid);      // 递归左半部分
        mergeSort(arr, mid + 1, right); // 递归右半部分
        merge(arr, left, mid, right);   // 合并操作 O(n)
    }
}
```
- **时间复杂度：O(n log n)** - 高效的递归分治

### 2. **低效的递归** ❌

**您的爬楼梯问题（朴素递归）**
```cpp
int climbStairs(int n) {
    if (n == 0 || n == 1) return 1;
    return climbStairs(n - 1) + climbStairs(n - 2); // 重复计算严重
}
```
- **时间复杂度：O(2^n)** - 指数级，效率极低

### 3. **通过优化变高效的递归** 🔄

**记忆化递归（Memoization）**
```cpp
int climbStairsMemo(int n, vector<int>& memo) {
    if (n == 0 || n == 1) return 1;
    if (memo[n] != -1) return memo[n]; // 如果已经计算过，直接返回
    
    memo[n] = climbStairsMemo(n - 1, memo) + climbStairsMemo(n - 2, memo);
    return memo[n];
}
```
- **时间复杂度：O(n)** - 每个子问题只计算一次

## 判断递归效率的关键因素

| 因素 | 高效递归 | 低效递归 |
|------|----------|----------|
| **子问题重叠性** | 无重叠或少量重叠 | 大量重叠子问题 |
| **递归分支数** | 单分支或固定分支 | 多分支且增长 |
| **问题规模缩减** | 每次规模显著减小（如减半） | 每次规模缓慢减小（如减1） |
| **重复计算** | 无重复计算 | 大量重复计算 |

## 递归 vs 迭代的效率对比

| 算法类型 | 递归复杂度 | 迭代复杂度 | 推荐 |
|----------|------------|------------|------|
| 二分查找 | O(log n) | O(log n) | 两者均可 |
| 斐波那契（朴素） | O(2^n) | O(n) | 迭代 |
| 斐波那契（记忆化） | O(n) | O(n) | 两者均可 |
| 树的遍历 | O(n) | O(n) | 递归更简洁 |

## 总结

**递归本身不是性能问题的根源，重复计算才是。**

- **好的递归**：分治策略、无重叠子问题、问题规模快速减小
- **差的递归**：大量重叠子问题、问题规模缓慢减小、无优化

**建议**：对于有重叠子问题的递归，使用记忆化或转换为动态规划；对于无重叠的递归，可以放心使用。