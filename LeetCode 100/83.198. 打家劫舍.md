___
这段代码是C++中用于**字符串解析**的常用技巧，让我详细解释每一部分：

## 代码功能概述
```cpp
stringstream ss(input);     // 1. 创建字符串流
int num;                    // 2. 声明整数变量
while (ss >> num) {         // 3. 循环读取数字
    nums.push_back(num);    // 4. 将数字添加到向量
}
```

## 逐行详细解释

### 第1行：`stringstream ss(input);`
- **`stringstream`**：这是一个输入/输出流类，专门用于处理字符串
- **`ss(input)`**：用字符串`input`初始化字符串流对象`ss`
- **作用**：将普通的字符串转换成可以像`cin`一样进行输入操作的数据流

**示例**：
```cpp
string input = "100 200 300 50";
stringstream ss(input);  // 现在ss就像一个包含这些数字的数据流
```

### 第2行：`int num;`
- 简单的变量声明，用于存储每次从流中提取的数字

### 第3行：`while (ss >> num)`
这是最关键的部分：

- **`ss >> num`**：从字符串流`ss`中提取一个整数到变量`num`
- **返回值**：这个表达式返回流对象本身，但可以被转换为布尔值
- **循环条件**：当提取成功时，条件为`true`；当遇到错误或流结束时，条件为`false`

**工作原理**：
```cpp
// 假设 input = "100 200 300"
ss >> num;  // 第一次：num = 100，返回true
ss >> num;  // 第二次：num = 200，返回true  
ss >> num;  // 第三次：num = 300，返回true
ss >> num;  // 第四次：流结束，返回false，循环退出
```

### 第4行：`nums.push_back(num);`
- 将成功提取的数字添加到向量`nums`的末尾

## 完整执行过程示例

假设用户输入：`"2 7 9 3 1"`

```cpp
string input = "2 7 9 3 1";
stringstream ss(input);
int num;
vector<int> nums;

// 第一次循环：ss >> num 提取到2，条件为true
// nums.push_back(2) → nums = [2]

// 第二次循环：ss >> num 提取到7，条件为true  
// nums.push_back(7) → nums = [2, 7]

// 第三次循环：ss >> num 提取到9，条件为true
// nums.push_back(9) → nums = [2, 7, 9]

// 第四次循环：ss >> num 提取到3，条件为true
// nums.push_back(3) → nums = [2, 7, 9, 3]

// 第五次循环：ss >> num 提取到1，条件为true
// nums.push_back(1) → nums = [2, 7, 9, 3, 1]

// 第六次循环：流结束，ss >> num 失败，条件为false，循环退出
```

## 为什么这种方式很实用？

1. **自动处理空格分隔**：不需要手动分割字符串
2. **类型安全**：自动将字符串转换为指定类型（这里是`int`）
3. **错误处理**：遇到非数字字符时会自动停止
4. **简洁高效**：几行代码完成复杂的解析任务

## 处理异常情况的例子

```cpp
string input = "10 20 abc 30 40";
stringstream ss(input);
int num;
vector<int> nums;

while (ss >> num) {
    nums.push_back(num);
}

// 结果：nums = [10, 20]
// 遇到"abc"时解析失败，循环退出
```

## 替代方案对比

**方法1：手动分割（更复杂）**
```cpp
// 需要更多代码，容易出错
size_t pos = 0;
while ((pos = input.find(' ')) != string::npos) {
    string token = input.substr(0, pos);
    nums.push_back(stoi(token));
    input.erase(0, pos + 1);
}
if (!input.empty()) {
    nums.push_back(stoi(input));
}
```

**方法2：使用stringstream（推荐）**
```cpp
// 简洁明了
stringstream ss(input);
int num;
while (ss >> num) {
    nums.push_back(num);
}
```

这就是为什么在C++中`stringstream`是处理字符串解析的首选工具！

---
你问的是三个相关但不同的输入流操作，让我详细解释它们的区别：

## 1. `cin.clear()` - 清除错误状态

**作用**：重置流的错误标志位，让流恢复正常状态

```cpp
cin.clear(); // 清除所有错误标志
```

**使用场景**：
- 当输入操作失败后（比如期望输入数字却输入了字母）
- 恢复流的可操作状态

**示例**：
```cpp
int number;
cout << "请输入一个数字: ";
cin >> number;

if (cin.fail()) { // 如果输入失败（比如输入了字母）
    cin.clear();  // 清除错误状态，让cin恢复正常
    cout << "输入错误，请重新输入" << endl;
}
```

## 2. `cin.ignore()` - 忽略/丢弃字符

**作用**：从输入流中丢弃指定数量的字符

```cpp
// 基本形式：忽略1个字符
cin.ignore();

// 常用形式：忽略直到换行符的所有字符
cin.ignore(numeric_limits<streamsize>::max(), '\n');
```

**参数说明**：
- 第一个参数：要忽略的最大字符数
- 第二个参数（可选）：遇到此字符时停止忽略

**示例**：
```cpp
char ch;
cout << "输入一个字符: ";
cin >> ch;
cin.ignore(100, '\n'); // 忽略缓冲区中最多100个字符，或直到遇到换行符

cout << "输入一句话: ";
string sentence;
getline(cin, sentence); // 现在可以正常读取整行
```

## 3. `cin >> variable` - 提取操作符

**作用**：从输入流中提取数据并存储到变量中

```cpp
int age;
cin >> age; // 从输入流提取整数到age变量
```

**特点**：
- 会自动跳过前导空白字符（空格、制表符、换行符）
- 遇到不匹配的数据类型时会失败
- **不会读取换行符**，会留在缓冲区中

## 三者的区别对比

| 操作 | 作用 | 影响缓冲区 | 常用场景 |
|------|------|------------|----------|
| `cin.clear()` | 清除错误状态 | 不改变缓冲区内容 | 输入失败后恢复流状态 |
| `cin.ignore()` | 丢弃字符 | 移除缓冲区中的字符 | 清理残留的换行符或错误输入 |
| `cin >> var` | 提取数据 | 读取并移除匹配的数据 | 正常的数据输入 |

## 实际组合使用示例

### 场景：混合使用`cin >>`和`getline()`

```cpp
#include <iostream>
#include <limits>
using namespace std;

int main() {
    int age;
    string name;
    
    cout << "请输入年龄: ";
    cin >> age;
    
    // 问题：上面的cin >> 留下了换行符在缓冲区
    // 下面的getline()会立即读到空行
    
    // 解决方案：清除缓冲区中的换行符
    cin.ignore(numeric_limits<streamsize>::max(), '\n');
    
    cout << "请输入姓名: ";
    getline(cin, name); // 现在可以正常读取
    
    cout << "年龄: " << age << ", 姓名: " << name << endl;
    return 0;
}
```

### 场景：错误恢复完整流程

```cpp
#include <iostream>
#include <limits>
using namespace std;

int main() {
    int number;
    
    while (true) {
        cout << "请输入一个数字: ";
        cin >> number;
        
        if (cin.fail()) { // 输入失败（比如输入了字母）
            cin.clear(); // 1. 清除错误状态
            cin.ignore(numeric_limits<streamsize>::max(), '\n'); // 2. 清除错误输入
            cout << "输入无效，请重新输入数字！" << endl;
        } else {
            cin.ignore(numeric_limits<streamsize>::max(), '\n'); // 3. 清除换行符
            break; // 输入成功，退出循环
        }
    }
    
    cout << "你输入的数字是: " << number << endl;
    return 0;
}
```

## 总结

- **`cin.clear()`**：修复流的状态，让它可以继续工作
- **`cin.ignore()`**：清理缓冲区中的"垃圾"数据
- **`cin >> variable`**：正常的读取操作

它们通常**组合使用**来解决输入缓冲区的各种问题，特别是在混合使用不同输入方法时。

---
`getline(cin, input)` 是C++中一个非常重要的输入函数，让我详细解释它的用法和特点：

## 基本语法和功能

```cpp
getline(cin, input);
```

- **`getline()`**：标准库函数，用于读取整行文本
- **`cin`**：标准输入流（键盘输入）
- **`input`**：一个`string`类型的变量，用于存储读取的内容

## 与 `cin >>` 的关键区别

| 特性 | `cin >> variable` | `getline(cin, input)` |
|------|-------------------|---------------------|
| **读取方式** | 读取到空白符停止 | 读取整行直到换行符 |
| **处理空格** | 跳过前导空白，遇到空格停止 | 读取包括空格在内的所有字符 |
| **换行符** | 留在输入缓冲区中 | 读取并丢弃换行符 |
| **适用场景** | 读取单个单词/数字 | 读取整行文本/句子 |

## 实际示例对比

### 示例1：读取单个单词 vs 整行
```cpp
#include <iostream>
#include <string>
using namespace std;

int main() {
    string word, line;
    
    cout << "输入一句话: ";
    cin >> word;  // 只读取第一个单词
    cout << "cin >> 结果: " << word << endl;
    
    // 清除缓冲区中的剩余内容
    cin.ignore(numeric_limits<streamsize>::max(), '\n');
    
    cout << "再输入一句话: ";
    getline(cin, line);  // 读取整行
    cout << "getline() 结果: " << line << endl;
    
    return 0;
}
```

**运行结果**：
```
输入一句话: Hello World
cin >> 结果: Hello
再输入一句话: Hello World
getline() 结果: Hello World
```

### 示例2：在打家劫舍程序中的应用
```cpp
void test() {
    vector<int> nums;
    string input;
    
    cout << "请输入房屋金额数组（用空格分隔）: ";
    getline(cin, input);  // 读取用户输入的一整行
    
    // 使用stringstream解析空格分隔的数字
    stringstream ss(input);
    int num;
    while (ss >> num) {
        nums.push_back(num);
    }
    
    // 现在nums包含了所有输入的数字
    // 例如：输入"100 200 300" → nums = [100, 200, 300]
}
```

## 为什么在测试程序中要用 `getline(cin, input)`？

### 传统方法的局限性
```cpp
// 方法1：逐个输入（繁琐）
int n;
cout << "输入数字个数: ";
cin >> n;
for (int i = 0; i < n; i++) {
    int num;
    cin >> num;
    nums.push_back(num);
}
// 问题：需要用户先数一下有多少个数字，很麻烦

// 方法2：直接循环读取（不灵活）
int num;
while (cin >> num) {
    nums.push_back(num);
}
// 问题：不知道何时停止，需要特殊方式结束输入
```

### `getline()` 的优势
```cpp
// 方法3：使用getline()（推荐）
string input;
getline(cin, input);  // 一次读取整行
stringstream ss(input);
int num;
while (ss >> num) {
    nums.push_back(num);
}
// 优势：用户可以一次性输入所有数字，用空格分隔
// 例如："2 7 9 3 1" → 自动解析为5个数字
```

## 常见问题及解决方案

### 问题1：`cin >>` 后接 `getline()` 的陷阱
```cpp
int age;
string name;

cout << "请输入年龄: ";
cin >> age;  // 用户输入后按回车，换行符留在缓冲区

cout << "请输入姓名: ";
getline(cin, name);  // 立即读到空字符串！

// 解决方案：在cin >> 后清除缓冲区
cin.ignore(numeric_limits<streamsize>::max(), '\n');
getline(cin, name);  // 现在可以正常读取
```

### 问题2：处理空行输入
```cpp
string input;
getline(cin, input);

if (input.empty()) {
    cout << "检测到空输入，使用默认值" << endl;
    input = "1 2 3 4 5";  // 提供默认值
}
```

## 高级用法

### 指定分隔符
```cpp
// 默认以换行符为分隔符
getline(cin, input);  // 读取直到换行符

// 可以指定其他分隔符
getline(cin, input, ',');  // 读取直到逗号
```

### 在循环中使用
```cpp
vector<string> lines;
string line;

cout << "输入多行文本（空行结束）:" << endl;
while (getline(cin, line) && !line.empty()) {
    lines.push_back(line);
}
```

## 总结

`getline(cin, input)` 是处理用户文本输入的理想选择，特别是：
- 需要读取包含空格的整行文本时
- 用户需要一次性输入多个用空格分隔的值时
- 避免`cin >>`带来的缓冲区问题时

在你的打家劫舍程序中，它让用户可以方便地输入类似 `"100 200 300 50"` 这样的数字序列，大大提升了用户体验。