**是的，`ranges::` 不能省略**，除非您使用了相应的 `using` 声明。

## 为什么不能省略 `ranges::`

### 🚫 默认情况下必须使用命名空间限定

```cpp
#include <ranges>
#include <algorithm>

auto init = [] {
    // ❌ 错误：fill 未声明
    fill(dp, INT_MAX);
  
    // ✅ 正确：必须使用命名空间限定
    std::ranges::fill(dp, INT_MAX);
  
    return 0;
}();
```

### ✅ 省略 `ranges::` 的方法

#### 方法1：使用 `using` 声明

```cpp
#include <ranges>
#include <algorithm>

auto init = [] {
    using std::ranges::fill;  // 引入 fill 到当前作用域
  
    fill(dp, INT_MAX);  // ✅ 现在可以省略 std::ranges::
    dp[0] = 0;
    // ... 其余代码
  
    return 0;
}();
```

#### 方法2：使用 `using namespace`（不推荐）

```cpp
#include <ranges>
#include <algorithm>

auto init = [] {
    using namespace std::ranges;  // 引入整个 ranges 命名空间
  
    fill(dp, INT_MAX);  // ✅ 可以省略
    // ... 其余代码
  
    return 0;
}();
```

#### 方法3：全局使用（在函数外部）

```cpp
#include <ranges>
#include <algorithm>

using std::ranges::fill;  // 全局引入

auto init = [] {
    fill(dp, INT_MAX);  // ✅ 可以省略
    // ... 其余代码
  
    return 0;
}();
```

### ⚠️ 重要区别：`std::fill` vs `std::ranges::fill`

即使您使用了 `using namespace std;`，仍然需要区分：

```cpp
#include <algorithm>
#include <vector>

using namespace std;  // 引入 std 命名空间

vector<int> vec(10);

// 传统版本 - 需要迭代器
std::fill(vec.begin(), vec.end(), 42);

// 范围版本 - 需要 ranges::
std::ranges::fill(vec, 42);  // 即使有 using namespace std;
```

### 🎯 推荐做法

**最安全、最清晰的做法是保持完整的限定**：

```cpp
auto init = [] {
    std::ranges::fill(dp, INT_MAX);  // 清晰明确
  
    // 或者使用传统版本（如果 ranges 不可用）
    // std::fill(std::begin(dp), std::end(dp), INT_MAX);
  
    return 0;
}();
```

### 💡 总结

- `ranges::` **不能省略**，因为它是独立的命名空间
- 只有在使用 `using` 声明后才能省略
- 保持完整的命名空间限定通常是最佳实践，可以提高代码可读性和避免命名冲突

保持 `std::ranges::fill` 的写法是最推荐的方式！
